import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import json
import math
import datetime
import os
from typing import Dict, List, Tuple, Optional

class GPSNavigator:
    def __init__(self, root):
        self.root = root
        self.root.title("GPS Navigator - Nawigacja po ≈õcie≈ºce")
        self.root.geometry("1000x800")
        
        # Dane
        self.all_paths = []
        self.all_connections = []
        self.shortest_path = []
        self.path_segments = []
        self.nodes_coords = {}
        self.point_labels = {}  # Etykiety punkt√≥w (ID -> nazwa)
        
        # Stan u≈ºytkownika
        self.user_position = None
        self.current_path_index = 0
        self.is_drawing = False
        self.drawn_path = []
        self.proximity_threshold = 30  # Odleg≈Ço≈õƒá w pikselach do uznania ≈ºe u≈ºytkownik dotar≈Ç
        
        # ≈öcie≈ºki u≈ºytkownik√≥w do aktualizacji mapy
        self.user_paths_history = []  # Lista wszystkich przej≈õƒá u≈ºytkownik√≥w
        self.current_user_path = []  # Aktualna ≈õcie≈ºka u≈ºytkownika
        self.map_filename = None  # Nazwa pliku z mapƒÖ
        
        # Kierunek ruchu u≈ºytkownika (do nawigacji wzglƒôdnej)
        self.user_direction = None  # KƒÖt w radianach
        self.last_positions = []  # Ostatnie kilka pozycji do obliczenia kierunku
        
        # Kontrola zgodno≈õci z trasƒÖ
        self.route_deviation_threshold = 50  # Odleg≈Ço≈õƒá od trasy uznawana za odstƒôpstwo
        self.deviated_from_route = False  # Czy u≈ºytkownik zboczy≈Ç z trasy
        self.visited_nodes = []  # Wƒôz≈Çy kt√≥re u≈ºytkownik faktycznie odwiedzi≈Ç
        
        # Tryb wolnej eksploracji
        self.free_exploration_mode = False
        
        self.setup_ui()
        
        # Automatycznie wczytaj pliki przy starcie
        self.root.after(100, self.auto_load_files)
    
    def auto_load_files(self):
        """Automatycznie wczytuje pliki gps_paths.json i shortest_path.json"""
        # Wczytaj mapƒô
        if self.load_map():
            # Je≈õli mapa OK, spr√≥buj wczytaƒá trasƒô
            self.load_route()
    
    def setup_ui(self):
        """Konfiguracja interfejsu u≈ºytkownika"""
        # Panel g√≥rny - przyciski
        top_frame = tk.Frame(self.root, bg='#f0f0f0', pady=10)
        top_frame.pack(side=tk.TOP, fill=tk.X)
        
        tk.Button(top_frame, text="üìÇ Wczytaj mapƒô (GPS paths)", 
                 command=self.load_map,
                 bg='#4CAF50', fg='white', font=('Arial', 10, 'bold'),
                 padx=10, pady=8).pack(side=tk.LEFT, padx=5)
        
        tk.Button(top_frame, text="üéØ Wczytaj trasƒô (Shortest path)", 
                 command=self.load_route,
                 bg='#2196F3', fg='white', font=('Arial', 10, 'bold'),
                 padx=10, pady=8).pack(side=tk.LEFT, padx=5)
        
        tk.Frame(top_frame, width=2, bg='gray').pack(side=tk.LEFT, fill=tk.Y, padx=10)
        
        tk.Button(top_frame, text="üö∂ Rozpocznij nawigacjƒô", 
                 command=self.start_navigation,
                 bg='#FF5722', fg='white', font=('Arial', 10, 'bold'),
                 padx=10, pady=8).pack(side=tk.LEFT, padx=5)
        
        tk.Button(top_frame, text="ÔøΩÔ∏è Wolna eksploracja", 
                 command=self.start_free_exploration,
                 bg='#9C27B0', fg='white', font=('Arial', 10, 'bold'),
                 padx=10, pady=8).pack(side=tk.LEFT, padx=5)
        
        tk.Button(top_frame, text="ÔøΩüóëÔ∏è Wyczy≈õƒá pozycjƒô", 
                 command=self.clear_user_path,
                 bg='#f44336', fg='white', font=('Arial', 10, 'bold'),
                 padx=10, pady=8).pack(side=tk.LEFT, padx=5)
        
        tk.Frame(top_frame, width=2, bg='gray').pack(side=tk.LEFT, fill=tk.Y, padx=10)
        
        tk.Label(top_frame, text="Auto-update mapy:", 
                bg='#f0f0f0', font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        
        self.auto_update_var = tk.BooleanVar(value=True)
        tk.Checkbutton(top_frame, text="W≈ÇƒÖczone", variable=self.auto_update_var,
                      bg='#f0f0f0', font=('Arial', 9, 'bold'),
                      activebackground='#f0f0f0').pack(side=tk.LEFT)
        
        tk.Frame(top_frame, width=2, bg='gray').pack(side=tk.LEFT, fill=tk.Y, padx=10)
        
        tk.Button(top_frame, text="‚¨ÖÔ∏è Menu", 
                 command=self.return_to_menu,
                 bg='#607D8B', fg='white', font=('Arial', 9, 'bold'),
                 padx=10, pady=8).pack(side=tk.LEFT, padx=5)
        
        # Panel ustawie≈Ñ
        settings_frame = tk.Frame(self.root, bg='#e8f5e9', pady=8)
        settings_frame.pack(side=tk.TOP, fill=tk.X)
        
        tk.Label(settings_frame, text="Pr√≥g blisko≈õci (px):", 
                bg='#e8f5e9', font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        
        self.threshold_var = tk.IntVar(value=30)
        threshold_slider = tk.Scale(settings_frame, from_=10, to=100, 
                                   orient=tk.HORIZONTAL, variable=self.threshold_var,
                                   length=150, command=self.update_threshold)
        threshold_slider.pack(side=tk.LEFT, padx=5)
        
        self.threshold_label = tk.Label(settings_frame, text="30 px", 
                                       bg='#e8f5e9', font=('Arial', 9, 'bold'))
        self.threshold_label.pack(side=tk.LEFT, padx=5)
        
        tk.Frame(settings_frame, width=2, bg='gray').pack(side=tk.LEFT, fill=tk.Y, padx=15)
        
        tk.Label(settings_frame, text="Pr√≥bkowanie ≈õcie≈ºki (co N-ty punkt):", 
                bg='#e8f5e9', font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        
        self.sampling_var = tk.IntVar(value=50)
        sampling_slider = tk.Scale(settings_frame, from_=20, to=100, 
                                   orient=tk.HORIZONTAL, variable=self.sampling_var,
                                   length=150, command=self.update_sampling)
        sampling_slider.pack(side=tk.LEFT, padx=5)
        
        self.sampling_label = tk.Label(settings_frame, text="co 50", 
                                       bg='#e8f5e9', font=('Arial', 9, 'bold'))
        self.sampling_label.pack(side=tk.LEFT, padx=5)
        
        # Panel informacyjny - nawigacja
        self.nav_frame = tk.Frame(self.root, bg='#1976D2', pady=15)
        self.nav_frame.pack(side=tk.TOP, fill=tk.X)
        
        self.nav_label = tk.Label(self.nav_frame, 
                                 text="Wczytaj mapƒô i trasƒô aby rozpoczƒÖƒá nawigacjƒô",
                                 bg='#1976D2', fg='white', 
                                 font=('Arial', 14, 'bold'))
        self.nav_label.pack()
        
        self.distance_label = tk.Label(self.nav_frame, 
                                      text="",
                                      bg='#1976D2', fg='#BBDEFB', 
                                      font=('Arial', 11))
        self.distance_label.pack()
        
        # Panel canvas
        canvas_container = tk.Frame(self.root, bg='white')
        canvas_container.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Canvas do rysowania
        self.canvas = tk.Canvas(canvas_container, bg='white', 
                               cursor='crosshair')
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Legenda
        legend_frame = tk.Frame(self.root, bg='#f5f5f5', pady=5)
        legend_frame.pack(side=tk.BOTTOM, fill=tk.X)
        
        tk.Label(legend_frame, text="‚óè Szare linie: Mapa", 
                bg='#f5f5f5', fg='gray', font=('Arial', 9)).pack(side=tk.LEFT, padx=10)
        tk.Label(legend_frame, text="‚óè Czerwona linia: Trasa do przej≈õcia", 
                bg='#f5f5f5', fg='red', font=('Arial', 9, 'bold')).pack(side=tk.LEFT, padx=10)
        tk.Label(legend_frame, text="‚óè Niebieska linia: Twoja pozycja", 
                bg='#f5f5f5', fg='blue', font=('Arial', 9, 'bold')).pack(side=tk.LEFT, padx=10)
        tk.Label(legend_frame, text="üü¢ Start", 
                bg='#f5f5f5', font=('Arial', 9)).pack(side=tk.LEFT, padx=10)
        tk.Label(legend_frame, text="üî¥ Cel", 
                bg='#f5f5f5', font=('Arial', 9)).pack(side=tk.LEFT, padx=10)
        
    def update_threshold(self, value):
        """Aktualizuje pr√≥g blisko≈õci"""
        self.proximity_threshold = int(value)
        self.threshold_label['text'] = f"{value} px"
    
    def update_sampling(self, value):
        """Aktualizuje czƒôstotliwo≈õƒá pr√≥bkowania"""
        self.sampling_label['text'] = f"co {value}"
        
    def load_map(self):
        """Automatycznie wczytuje mapƒô z gps_paths.json"""
        filename = "gps_paths.json"
        
        if not os.path.exists(filename):
            messagebox.showerror("B≈ÇƒÖd", 
                               f"Nie znaleziono pliku: {filename}\n\n"
                               f"Utw√≥rz mapƒô w Map Maker najpierw.")
            return False
        
        self.map_filename = filename
            
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            self.all_paths = data.get('paths', [])
            self.all_connections = data.get('connections', [])
            
            # Wczytaj etykiety punkt√≥w je≈õli istniejƒÖ
            self.point_labels = data.get('point_labels', {})
            
            print(f"‚úì Automatycznie wczytano mapƒô: {filename}")
            print(f"  ≈öcie≈ºki: {len(self.all_paths)}")
            print(f"  Po≈ÇƒÖczenia: {len(self.all_connections)}")
            print(f"  Etykiety: {len(self.point_labels)}")
            
            self.draw_map()
            return True
            
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô wczytaƒá mapy:\n{e}")
            return False
    
    def load_route(self):
        """Automatycznie wczytuje trasƒô z shortest_path.json"""
        filename = "shortest_path.json"
        
        if not os.path.exists(filename):
            messagebox.showwarning("Brak trasy", 
                                  f"Nie znaleziono pliku: {filename}\n\n"
                                  f"U≈ºyj Graph Analyzer aby wygenerowaƒá trasƒô.")
            return False
            
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            path_data = data.get('shortest_path', {})
            self.shortest_path = path_data.get('path', [])
            self.path_segments = data.get('path_segments', [])
            self.nodes_coords = data.get('nodes_coordinates', {})
            
            if not self.shortest_path:
                messagebox.showwarning("Pusta trasa", "Nie znaleziono trasy w pliku!")
                return False
            
            # Przygotuj ≈Çadne nazwy tras
            start_id = self.shortest_path[0]
            end_id = self.shortest_path[-1]
            start_label = self.point_labels.get(start_id, f"Punkt {start_id}")
            end_label = self.point_labels.get(end_id, f"Punkt {end_id}")
            
            print(f"‚úì Automatycznie wczytano trasƒô: {filename}")
            print(f"  Start: {start_label}")
            print(f"  Cel: {end_label}")
            print(f"  Punkty: {len(self.shortest_path)}")
            
            self.draw_route()
            return True
            
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô wczytaƒá trasy:\n{e}")
            return False
    
    def draw_map(self):
        """Rysuje mapƒô wszystkich ≈õcie≈ºek"""
        if not self.all_paths:
            return
        
        # Rysuj wszystkie po≈ÇƒÖczenia jako szare linie
        for connection in self.all_connections:
            # Znajd≈∫ wsp√≥≈Çrzƒôdne punkt√≥w
            from_id = str(connection['from'])
            to_id = str(connection['to'])
            
            from_coords = self.find_point_coords(from_id)
            to_coords = self.find_point_coords(to_id)
            
            if from_coords and to_coords:
                self.canvas.create_line(
                    from_coords[0], from_coords[1],
                    to_coords[0], to_coords[1],
                    fill='lightgray', width=2, tags='map'
                )
    
    def find_point_coords(self, point_id: str) -> Optional[Tuple[float, float]]:
        """Znajduje wsp√≥≈Çrzƒôdne punktu po ID"""
        for path in self.all_paths:
            for point in path['points']:
                if str(point['id']) == point_id:
                    return (point['x'], point['y'])
        return None
    
    def draw_route(self):
        """Rysuje trasƒô do przej≈õcia"""
        if not self.nodes_coords:
            return
        
        # Usu≈Ñ poprzedniƒÖ trasƒô
        self.canvas.delete('route')
        self.canvas.delete('markers')
        
        # Rysuj trasƒô jako czerwonƒÖ liniƒô
        for i in range(len(self.shortest_path) - 1):
            node_from = self.shortest_path[i]
            node_to = self.shortest_path[i + 1]
            
            if node_from in self.nodes_coords and node_to in self.nodes_coords:
                from_coords = self.nodes_coords[node_from]
                to_coords = self.nodes_coords[node_to]
                
                self.canvas.create_line(
                    from_coords['x'], from_coords['y'],
                    to_coords['x'], to_coords['y'],
                    fill='red', width=5, tags='route'
                )
        
        # Zaznacz punkty
        for i, node in enumerate(self.shortest_path):
            if node in self.nodes_coords:
                coords = self.nodes_coords[node]
                x, y = coords['x'], coords['y']
                
                # Pobierz etykietƒô je≈õli istnieje
                label = self.point_labels.get(node, f"#{node}")
                
                if i == 0:  # Start
                    self.canvas.create_oval(x-10, y-10, x+10, y+10,
                                          fill='green', outline='darkgreen',
                                          width=2, tags='markers')
                    self.canvas.create_text(x, y-20, text=f'START\n{label}',
                                          fill='green', font=('Arial', 9, 'bold'),
                                          tags='markers')
                elif i == len(self.shortest_path) - 1:  # Cel
                    self.canvas.create_oval(x-10, y-10, x+10, y+10,
                                          fill='red', outline='darkred',
                                          width=2, tags='markers')
                    self.canvas.create_text(x, y-20, text=f'CEL\n{label}',
                                          fill='red', font=('Arial', 9, 'bold'),
                                          tags='markers')
                else:  # Punkt po≈õredni
                    self.canvas.create_oval(x-6, y-6, x+6, y+6,
                                          fill='orange', outline='darkorange',
                                          width=2, tags='markers')
                    # Pokazuj etykietƒô dla punkt√≥w po≈õrednich je≈õli istnieje
                    if node in self.point_labels:
                        self.canvas.create_text(x, y-12, text=label,
                                              fill='orange', font=('Arial', 7),
                                              tags='markers')
    
    def start_navigation(self):
        """Rozpoczyna nawigacjƒô"""
        if not self.shortest_path or not self.nodes_coords:
            messagebox.showwarning("Brak danych", 
                                  "Najpierw wczytaj mapƒô i trasƒô!")
            return
        
        # Reset stanu
        self.current_path_index = 0
        self.drawn_path = []
        self.user_position = None
        self.canvas.delete('user_path')
        self.canvas.delete('user_marker')
        self.deviated_from_route = False
        self.visited_nodes = []
        
        # Pod≈ÇƒÖcz eventy myszy
        self.canvas.bind('<ButtonPress-1>', self.start_drawing)
        self.canvas.bind('<B1-Motion>', self.draw_user_path)
        self.canvas.bind('<ButtonRelease-1>', self.stop_drawing)
        
        # Przygotuj nazwƒô poczƒÖtkowego punktu
        first_point = self.shortest_path[0]
        first_label = self.point_labels.get(first_point, f"punkt {first_point}")
        
        self.nav_label['text'] = "üö∂ Rysuj swojƒÖ pozycjƒô myszkƒÖ (przeciƒÖgnij)"
        self.distance_label['text'] = f"Id≈∫ do: {first_label}"
        
        messagebox.showinfo("Nawigacja rozpoczƒôta", 
                          "Rysuj swojƒÖ ≈õcie≈ºkƒô myszkƒÖ!\n\n"
                          "System bƒôdzie ≈õledziƒá TwojƒÖ pozycjƒô i dawaƒá wskaz√≥wki.")
    
    def start_free_exploration(self):
        """Rozpoczyna wolnƒÖ eksploracjƒô bez nawigacji"""
        if not self.all_paths:
            messagebox.showwarning("Brak mapy", 
                                  "Najpierw wczytaj mapƒô!")
            return
        
        # Aktywuj tryb wolnej eksploracji
        self.free_exploration_mode = True
        
        # Reset stanu
        self.current_path_index = 0
        self.drawn_path = []
        self.user_position = None
        self.canvas.delete('user_path')
        self.canvas.delete('user_marker')
        self.deviated_from_route = False
        self.visited_nodes = []
        self.shortest_path = []  # Brak trasy do podƒÖ≈ºania
        
        # Pod≈ÇƒÖcz eventy myszy
        self.canvas.bind('<ButtonPress-1>', self.start_drawing)
        self.canvas.bind('<B1-Motion>', self.draw_user_path)
        self.canvas.bind('<ButtonRelease-1>', self.stop_drawing)
        
        # Zmie≈Ñ kolor t≈Ça nawigacji
        self.nav_frame['bg'] = '#9C27B0'
        self.nav_label['bg'] = '#9C27B0'
        self.distance_label['bg'] = '#9C27B0'
        
        self.nav_label['text'] = "üó∫Ô∏è WOLNA EKSPLORACJA - Odkrywaj nowe trasy!"
        self.distance_label['text'] = "Rysuj swojƒÖ ≈õcie≈ºkƒô myszkƒÖ - tworzysz nowƒÖ trasƒô"
        
        messagebox.showinfo("Wolna eksploracja", 
                          "üó∫Ô∏è Tryb wolnej eksploracji aktywowany!\n\n"
                          "Rysuj swojƒÖ ≈õcie≈ºkƒô myszkƒÖ bez wskaz√≥wek nawigacyjnych.\n"
                          "Twoja trasa zostanie dodana do mapy.\n\n"
                          "To ≈õwietny spos√≥b na odkrywanie nowych po≈ÇƒÖcze≈Ñ!")
    
    def start_drawing(self, event):
        """Rozpoczyna rysowanie ≈õcie≈ºki u≈ºytkownika"""
        self.is_drawing = True
        self.user_position = (event.x, event.y)
        self.drawn_path = [(event.x, event.y)]
        self.current_user_path = [(event.x, event.y)]
    
    def draw_user_path(self, event):
        """Rysuje ≈õcie≈ºkƒô u≈ºytkownika"""
        if not self.is_drawing:
            return
        
        # Dodaj punkt do ≈õcie≈ºki
        x, y = event.x, event.y
        
        if self.drawn_path:
            prev_x, prev_y = self.drawn_path[-1]
            
            # Rysuj liniƒô
            self.canvas.create_line(prev_x, prev_y, x, y,
                                  fill='blue', width=4, tags='user_path')
        
        self.drawn_path.append((x, y))
        self.current_user_path.append((x, y))
        self.user_position = (x, y)
        
        # Aktualizuj kierunek ruchu u≈ºytkownika
        self.last_positions.append((x, y))
        if len(self.last_positions) > 10:  # Zachowaj ostatnie 10 pozycji
            self.last_positions.pop(0)
        
        # Oblicz kierunek z ostatnich pozycji
        if len(self.last_positions) >= 5:
            # We≈∫ pierwszƒÖ i ostatniƒÖ pozycjƒô z ostatnich 5
            old_pos = self.last_positions[-5]
            new_pos = self.last_positions[-1]
            
            dx = new_pos[0] - old_pos[0]
            dy = new_pos[1] - old_pos[1]
            
            # Oblicz kƒÖt ruchu u≈ºytkownika (w radianach)
            if abs(dx) > 1 or abs(dy) > 1:  # Tylko je≈õli jest ruch
                self.user_direction = math.atan2(dy, dx)
        
        # Sprawd≈∫ nawigacjƒô
        self.check_navigation()
    
    def stop_drawing(self, event):
        """Ko≈Ñczy rysowanie ≈õcie≈ºki u≈ºytkownika"""
        self.is_drawing = False
        
        # Zaznacz aktualnƒÖ pozycjƒô
        self.canvas.delete('user_marker')
        if self.user_position:
            x, y = self.user_position
            self.canvas.create_oval(x-8, y-8, x+8, y+8,
                                  fill='blue', outline='darkblue',
                                  width=2, tags='user_marker')
        
        # W trybie wolnej eksploracji - zako≈Ñcz i zapisz trasƒô
        if self.free_exploration_mode and len(self.current_user_path) > 5:
            result = messagebox.askyesno("Zako≈Ñcz eksploracjƒô",
                                        f"Utworzono trasƒô z {len(self.current_user_path)} punkt√≥w.\n\n"
                                        f"Czy chcesz zapisaƒá tƒô trasƒô do mapy?")
            if result:
                self.update_map_with_user_path()
                messagebox.showinfo("Zapisano!", 
                                  "Twoja nowa trasa zosta≈Ça dodana do mapy! üó∫Ô∏è\n\n"
                                  "Mo≈ºesz teraz rozpoczƒÖƒá kolejnƒÖ eksploracjƒô.")
            
            # Reset trybu
            self.free_exploration_mode = False
            self.nav_frame['bg'] = '#1976D2'
            self.nav_label['bg'] = '#1976D2'
            self.distance_label['bg'] = '#1976D2'
            self.nav_label['text'] = "Eksploracja zako≈Ñczona"
            self.distance_label['text'] = ""
    
    def check_navigation(self):
        """Sprawdza postƒôp nawigacji i daje wskaz√≥wki"""
        if not self.user_position:
            return
        
        # W trybie wolnej eksploracji - tylko pokazuj informacje o eksploracji
        if self.free_exploration_mode:
            path_length = len(self.current_user_path)
            self.distance_label['text'] = f"üó∫Ô∏è Utworzono {path_length} punkt√≥w trasy"
            return
        
        # PRIORYTET 1: Sprawd≈∫ czy u≈ºytkownik dotar≈Ç do KO≈ÉCOWEGO celu (ostatni punkt)
        final_target = self.shortest_path[-1] if self.shortest_path else None
        
        if final_target and final_target in self.nodes_coords:
            final_coords = self.nodes_coords[final_target]
            final_x, final_y = final_coords['x'], final_coords['y']
            user_x, user_y = self.user_position
            
            final_distance = math.sqrt((final_x - user_x)**2 + (final_y - user_y)**2)
            
            # Je≈õli u≈ºytkownik dotar≈Ç do ko≈Ñcowego celu (nawet innƒÖ trasƒÖ)
            if final_distance <= self.proximity_threshold:
                # Oznacz jako odwiedzony
                if final_target not in self.visited_nodes:
                    self.visited_nodes.append(final_target)
                
                # KONIEC NAWIGACJI
                self.current_path_index = len(self.shortest_path)  # Ustaw na koniec
                
                self.nav_label['text'] = "üéâ GRATULACJE! Dotar≈Çe≈õ do celu!"
                self.distance_label['text'] = ""
                
                # Sprawd≈∫ czy u≈ºytkownik poszed≈Ç sugerowanƒÖ trasƒÖ
                self.check_route_compliance()
                return
        
        # PRIORYTET 2: Sprawd≈∫ postƒôp na sugerowanej trasie (punkty po≈õrednie)
        if self.current_path_index >= len(self.shortest_path):
            return
        
        # Pobierz aktualny cel na sugerowanej trasie
        current_target = self.shortest_path[self.current_path_index]
        
        if current_target not in self.nodes_coords:
            return
        
        target_coords = self.nodes_coords[current_target]
        target_x, target_y = target_coords['x'], target_coords['y']
        user_x, user_y = self.user_position
        
        # Oblicz odleg≈Ço≈õƒá do bie≈ºƒÖcego punktu po≈õredniego
        distance = math.sqrt((target_x - user_x)**2 + (target_y - user_y)**2)
        
        # Sprawd≈∫ czy u≈ºytkownik dotar≈Ç do punktu po≈õredniego
        if distance <= self.proximity_threshold:
            self.current_path_index += 1
            
            # Zapisz odwiedzony wƒôze≈Ç
            if current_target not in self.visited_nodes:
                self.visited_nodes.append(current_target)
            
            # Usu≈Ñ osiƒÖgniƒôty punkt
            self.canvas.delete('markers')
            self.draw_route()
            
            # Sprawd≈∫ czy to by≈Ç ostatni punkt
            if self.current_path_index >= len(self.shortest_path):
                self.nav_label['text'] = "üéâ GRATULACJE! Dotar≈Çe≈õ do celu!"
                self.distance_label['text'] = ""
                self.check_route_compliance()
                return
            else:
                # Nastƒôpny punkt po≈õredni
                next_target = self.shortest_path[self.current_path_index]
                next_label = self.point_labels.get(next_target, f"punkt {next_target}")
                self.nav_label['text'] = f"‚úì Dobra robota! Teraz id≈∫ do: {next_label}"
                return
        
        # PRIORYTET 3: Nawigacja - wskaz√≥wki jak doj≈õƒá do punktu
        # Sprawd≈∫ czy u≈ºytkownik nie zboczy≈Ç z trasy
        deviation_status = self.check_route_deviation()
        
        # Je≈õli u≈ºytkownik przeciera nowe szlaki, nie dawaj wskaz√≥wek nawigacyjnych
        if deviation_status == "exploring":
            target_label = self.point_labels.get(final_target if final_target else current_target, 
                                                 f"punkt {final_target if final_target else current_target}")
            self.nav_label['text'] = f"üó∫Ô∏è Przecierasz nowe szlaki! (Cel: {target_label})"
            return
        
        # Wskaz√≥wki kierunkowe wzglƒôdem kierunku ruchu u≈ºytkownika
        dx = target_x - user_x
        dy = target_y - user_y
        
        # Okre≈õl kierunek (wzglƒôdny lub absolutny)
        if self.user_direction is not None:
            direction = self.get_relative_direction(dx, dy)
        else:
            # Je≈õli nie znamy kierunku u≈ºytkownika, u≈ºyj kierunk√≥w absolutnych
            direction = self.get_absolute_direction(dx, dy)
        
        # Przygotuj nazwƒô celu
        target_label = self.point_labels.get(current_target, f"punkt {current_target}")
        
        self.nav_label['text'] = f"üß≠ {direction} do: {target_label}"
        self.distance_label['text'] = f"Odleg≈Ço≈õƒá: {distance:.1f} px (pr√≥g: {self.proximity_threshold} px)"
    
    def check_route_deviation(self):
        """Sprawdza czy u≈ºytkownik zboczy≈Ç z sugerowanej trasy
        
        Returns:
            str: "exploring" je≈õli przeciera nowe szlaki, "deviated" je≈õli zboczy≈Ç, None je≈õli na trasie
        """
        if not self.user_position or self.deviated_from_route:
            return None
        
        # Sprawd≈∫ odleg≈Ço≈õƒá od najbli≈ºszego punktu na sugerowanej trasie
        min_distance = float('inf')
        
        for node in self.shortest_path:
            if node not in self.nodes_coords:
                continue
            
            coords = self.nodes_coords[node]
            nx, ny = coords['x'], coords['y']
            ux, uy = self.user_position
            
            dist = math.sqrt((nx - ux)**2 + (ny - uy)**2)
            if dist < min_distance:
                min_distance = dist
        
        # Je≈õli u≈ºytkownik jest daleko od trasy
        if min_distance > self.route_deviation_threshold:
            self.deviated_from_route = True
            
            # Je≈õli BARDZO daleko (2x pr√≥g), to przeciera nowe szlaki
            exploration_threshold = self.route_deviation_threshold * 2
            if min_distance > exploration_threshold:
                self.distance_label['text'] = "üó∫Ô∏è PRZECIERASZ NOWE SZLAKI!"
                return "exploring"
            else:
                self.distance_label['text'] += " ‚ö†Ô∏è ODSTƒòPSTWO OD TRASY"
                return "deviated"
        
        return None
    
    def check_route_compliance(self):
        """Sprawdza czy u≈ºytkownik przeszed≈Ç sugerowanƒÖ trasƒÖ i pyta o pow√≥d je≈õli nie"""
        # Sprawd≈∫ czy u≈ºytkownik odwiedzi≈Ç wszystkie punkty z sugerowanej trasy (w kolejno≈õci)
        expected_nodes = self.shortest_path
        visited_nodes = self.visited_nodes
        
        # Sprawd≈∫ czy u≈ºytkownik odwiedzi≈Ç wszystkie punkty po≈õrednie
        all_nodes_visited = all(node in visited_nodes for node in expected_nodes)
        
        # Sprawd≈∫ czy u≈ºytkownik odwiedzi≈Ç je w tej samej kolejno≈õci
        in_correct_order = True
        last_expected_index = -1
        
        for expected_node in expected_nodes:
            try:
                visited_index = visited_nodes.index(expected_node)
                if visited_index < last_expected_index:
                    in_correct_order = False
                    break
                last_expected_index = visited_index
            except ValueError:
                # Wƒôze≈Ç nie zosta≈Ç odwiedzony
                in_correct_order = False
                break
        
        # Je≈õli u≈ºytkownik zboczy≈Ç, nie odwiedzi≈Ç wszystkich punkt√≥w, lub nie w kolejno≈õci
        if self.deviated_from_route or not all_nodes_visited or not in_correct_order:
            # Poka≈º dialog z pytaniem o pow√≥d
            print(f"  Wykryto odstƒôpstwo:")
            print(f"    Zboczy≈Ç z trasy: {self.deviated_from_route}")
            print(f"    Wszystkie punkty odwiedzone: {all_nodes_visited}")
            print(f"    Poprawna kolejno≈õƒá: {in_correct_order}")
            print(f"    Oczekiwane: {expected_nodes}")
            print(f"    Odwiedzone: {visited_nodes}")
            
            self.ask_deviation_reason()
        else:
            # U≈ºytkownik przeszed≈Ç dok≈Çadnie sugerowanƒÖ trasƒÖ
            print(f"  ‚úì U≈ºytkownik przeszed≈Ç zgodnie z trasƒÖ")
            
            # Aktualizuj mapƒô
            if self.auto_update_var.get():
                self.update_map_with_user_path()
            
            messagebox.showinfo("Sukces!", 
                              "üéâ Gratulacje!\n\nDotar≈Çe≈õ do celu zgodnie z trasƒÖ!\n\n"
                              "Twoja trasa zosta≈Ça dodana do mapy.")
    
    def ask_deviation_reason(self):
        """Pyta u≈ºytkownika o pow√≥d odstƒôpstwa od trasy"""
        # Utw√≥rz okno dialogowe
        dialog = tk.Toplevel(self.root)
        dialog.title("Odstƒôpstwo od sugerowanej trasy")
        dialog.geometry("500x400")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Centruj okno
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (dialog.winfo_width() // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog.winfo_height() // 2)
        dialog.geometry(f"+{x}+{y}")
        
        # Nag≈Ç√≥wek
        header_frame = tk.Frame(dialog, bg='#FF9800', pady=15)
        header_frame.pack(fill=tk.X)
        
        tk.Label(header_frame, 
                text="‚ö†Ô∏è Zauwa≈ºyli≈õmy odstƒôpstwo od trasy",
                bg='#FF9800', fg='white',
                font=('Arial', 14, 'bold')).pack()
        
        tk.Label(header_frame,
                text="Pom√≥≈º nam ulepszyƒá nawigacjƒô",
                bg='#FF9800', fg='white',
                font=('Arial', 10)).pack()
        
        # Tre≈õƒá
        content_frame = tk.Frame(dialog, bg='white', pady=20)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        tk.Label(content_frame,
                text="Dotar≈Çe≈õ do celu, ale nie podƒÖ≈ºa≈Çe≈õ sugerowanƒÖ trasƒÖ.\n"
                     "Dlaczego wybra≈Çe≈õ innƒÖ drogƒô?",
                bg='white',
                font=('Arial', 11),
                wraplength=450,
                justify=tk.LEFT).pack(pady=10, padx=20)
        
        # Poka≈º trasƒô sugerowanƒÖ i rzeczywistƒÖ z etykietami
        expected_route = " ‚Üí ".join([self.point_labels.get(n, f"#{n}") for n in self.shortest_path[:5]])
        if len(self.shortest_path) > 5:
            expected_route += " ‚Üí ..."
        
        tk.Label(content_frame,
                text=f"Sugerowana: {expected_route}",
                bg='#FFF3E0',
                font=('Arial', 9, 'italic'),
                fg='#E65100',
                wraplength=450,
                justify=tk.LEFT,
                padx=10, pady=5).pack(pady=(0, 10), padx=20, fill=tk.X)
        
        # Zmienna do przechowania wyboru
        reason_var = tk.StringVar(value="")
        
        # Opcje do wyboru
        reasons = [
            ("üö∂ Zat≈Çoczony korytarz - zbyt wielu ludzi na sugerowanej trasie", "crowded"),
            ("‚ö° Znalaz≈Çem kr√≥tszƒÖ drogƒô ni≈º sugerowana", "shorter"),
            ("üöß Sugerowana droga by≈Ça zablokowana lub niedostƒôpna", "blocked"),
            ("‚ùå Sugerowana droga nie istnieje lub jest nieprawid≈Çowa", "nonexistent"),
            ("üîÄ Znam lepszƒÖ trasƒô (inna przyczyna)", "other"),
            ("üéØ Lubiƒô zwiedzaƒá - po prostu eksploracja", "exploring")
        ]
        
        for text, value in reasons:
            rb = tk.Radiobutton(content_frame,
                              text=text,
                              variable=reason_var,
                              value=value,
                              bg='white',
                              font=('Arial', 10),
                              wraplength=430,
                              justify=tk.LEFT,
                              activebackground='#e3f2fd',
                              pady=5)
            rb.pack(anchor=tk.W, padx=30, pady=3)
        
        # Pole tekstowe dla dodatkowych uwag
        tk.Label(content_frame,
                text="Dodatkowe uwagi (opcjonalnie):",
                bg='white',
                font=('Arial', 9, 'italic')).pack(anchor=tk.W, padx=30, pady=(10, 2))
        
        notes_text = tk.Text(content_frame, height=3, width=50, font=('Arial', 9))
        notes_text.pack(padx=30, pady=5)
        
        # Przyciski
        button_frame = tk.Frame(dialog, bg='#f5f5f5', pady=10)
        button_frame.pack(fill=tk.X, side=tk.BOTTOM)
        
        def submit_feedback():
            reason = reason_var.get()
            notes = notes_text.get("1.0", tk.END).strip()
            
            if not reason:
                messagebox.showwarning("Brak wyboru", 
                                      "Proszƒô wybraƒá pow√≥d odstƒôpstwa od trasy.",
                                      parent=dialog)
                return
            
            # Je≈õli to tylko eksploracja, nie zapisuj feedbacku
            if reason == "exploring":
                dialog.destroy()
                
                # Aktualizuj mapƒô je≈õli w≈ÇƒÖczone
                if self.auto_update_var.get():
                    self.update_map_with_user_path()
                
                messagebox.showinfo("Dziƒôkujemy!", 
                                  "üéâ Gratulacje! Dotar≈Çe≈õ do celu!\n\n"
                                  "Mi≈Çego zwiedzania! üó∫Ô∏è\n\n"
                                  "Twoja trasa zosta≈Ça dodana do mapy.")
                return
            
            # Zapisz feedback (dla innych powod√≥w)
            self.save_route_feedback(reason, notes)
            
            # Zamknij dialog
            dialog.destroy()
            
            # Aktualizuj mapƒô je≈õli w≈ÇƒÖczone
            if self.auto_update_var.get():
                self.update_map_with_user_path()
            
            messagebox.showinfo("Dziƒôkujemy!", 
                              "üéâ Gratulacje! Dotar≈Çe≈õ do celu!\n\n"
                              "Dziƒôkujemy za feedback - pomo≈ºe nam ulepszyƒá nawigacjƒô.\n\n"
                              "Twoja trasa zosta≈Ça dodana do mapy.")
        
        def skip_feedback():
            dialog.destroy()
            
            # Aktualizuj mapƒô je≈õli w≈ÇƒÖczone
            if self.auto_update_var.get():
                self.update_map_with_user_path()
            
            messagebox.showinfo("Sukces!", 
                              "üéâ Gratulacje!\n\nDotar≈Çe≈õ do celu!\n\n"
                              "Twoja trasa zosta≈Ça dodana do mapy.")
        
        tk.Button(button_frame, text="‚úì Wy≈õlij feedback", 
                 command=submit_feedback,
                 bg='#4CAF50', fg='white',
                 font=('Arial', 10, 'bold'),
                 padx=20, pady=8).pack(side=tk.LEFT, padx=10)
        
        tk.Button(button_frame, text="Pomi≈Ñ", 
                 command=skip_feedback,
                 bg='#9E9E9E', fg='white',
                 font=('Arial', 10),
                 padx=20, pady=8).pack(side=tk.LEFT, padx=10)
    
    def save_route_feedback(self, reason: str, notes: str):
        """Zapisuje feedback u≈ºytkownika o trasie"""
        feedback_data = {
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "suggested_route": self.shortest_path,
            "visited_nodes": self.visited_nodes,
            "deviated": self.deviated_from_route,
            "reason": reason,
            "notes": notes,
            "path_length": len(self.current_user_path)
        }
        
        # Zapisz do pliku JSON
        import os
        feedback_file = "route_feedback.json"
        
        try:
            # Wczytaj istniejƒÖce feedbacki
            if os.path.exists(feedback_file):
                with open(feedback_file, 'r', encoding='utf-8') as f:
                    all_feedback = json.load(f)
            else:
                all_feedback = []
            
            # Dodaj nowy feedback
            all_feedback.append(feedback_data)
            
            # Zapisz
            with open(feedback_file, 'w', encoding='utf-8') as f:
                json.dump(all_feedback, f, indent=2, ensure_ascii=False)
            
            print(f"‚úì Feedback zapisany do {feedback_file}")
            print(f"  Pow√≥d: {reason}")
            if notes:
                print(f"  Uwagi: {notes}")
            
        except Exception as e:
            print(f"‚úó B≈ÇƒÖd zapisu feedbacku: {e}")
    
    def get_relative_direction(self, dx: float, dy: float) -> str:
        """Okre≈õla kierunek wzglƒôdem aktualnego kierunku ruchu u≈ºytkownika"""
        # KƒÖt do celu (absolutny)
        target_angle = math.atan2(dy, dx)
        
        # R√≥≈ºnica miƒôdzy kierunkiem ruchu a kierunkiem do celu
        angle_diff = target_angle - self.user_direction
        
        # Normalizuj do zakresu -œÄ do œÄ
        while angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        while angle_diff < -math.pi:
            angle_diff += 2 * math.pi
        
        # Konwertuj na stopnie dla ≈Çatwiejszej analizy
        angle_diff_deg = math.degrees(angle_diff)
        
        # Okre≈õl kierunek wzglƒôdny
        if -22.5 <= angle_diff_deg <= 22.5:
            return "Id≈∫ prosto do przodu ‚¨ÜÔ∏è"
        elif 22.5 < angle_diff_deg <= 67.5:
            return "Skrƒôƒá lekko w prawo ‚ÜóÔ∏è"
        elif 67.5 < angle_diff_deg <= 112.5:
            return "Skrƒôƒá w prawo ‚û°Ô∏è"
        elif 112.5 < angle_diff_deg <= 157.5:
            return "Zawr√≥ƒá w prawo ‚Ü™Ô∏è"
        elif angle_diff_deg > 157.5 or angle_diff_deg < -157.5:
            return "Zawr√≥ƒá / id≈∫ w przeciwnym kierunku üîÑ"
        elif -157.5 <= angle_diff_deg < -112.5:
            return "Zawr√≥ƒá w lewo ‚Ü©Ô∏è"
        elif -112.5 <= angle_diff_deg < -67.5:
            return "Skrƒôƒá w lewo ‚¨ÖÔ∏è"
        elif -67.5 <= angle_diff_deg < -22.5:
            return "Skrƒôƒá lekko w lewo ‚ÜñÔ∏è"
        else:
            return "Id≈∫ do przodu ‚¨ÜÔ∏è"
    
    def get_absolute_direction(self, dx: float, dy: float) -> str:
        """Okre≈õla kierunek geograficzny (gdy nie znamy kierunku u≈ºytkownika)"""
        angle = math.atan2(dy, dx) * 180 / math.pi
        
        # Normalizuj kƒÖt (0-360)
        if angle < 0:
            angle += 360
        
        # Okre≈õl kierunek
        if 22.5 <= angle < 67.5:
            return "Id≈∫ na PO≈ÅUDNIOWY-WSCH√ìD ‚ÜòÔ∏è"
        elif 67.5 <= angle < 112.5:
            return "Id≈∫ na PO≈ÅUDNIE ‚¨áÔ∏è"
        elif 112.5 <= angle < 157.5:
            return "Id≈∫ na PO≈ÅUDNIOWY-ZACH√ìD ‚ÜôÔ∏è"
        elif 157.5 <= angle < 202.5:
            return "Id≈∫ na ZACH√ìD ‚¨ÖÔ∏è"
        elif 202.5 <= angle < 247.5:
            return "Id≈∫ na P√ì≈ÅNOCNY-ZACH√ìD ‚ÜñÔ∏è"
        elif 247.5 <= angle < 292.5:
            return "Id≈∫ na P√ì≈ÅNOC ‚¨ÜÔ∏è"
        elif 292.5 <= angle < 337.5:
            return "Id≈∫ na P√ì≈ÅNOCNY-WSCH√ìD ‚ÜóÔ∏è"
        else:
            return "Id≈∫ na WSCH√ìD ‚û°Ô∏è"
    
    def get_direction(self, dx: float, dy: float) -> str:
        """Stara funkcja - pozostawiona dla kompatybilno≈õci"""
        return self.get_absolute_direction(dx, dy)
    
    def merge_user_path_with_existing(self, user_points_coords, existing_points):
        """≈ÅƒÖczy punkty u≈ºytkownika z istniejƒÖcymi punktami (jak 'Po≈ÇƒÖcz korytarze')"""
        merge_threshold = 40  # Ten sam pr√≥g co w mapmaker
        
        merged_points = []
        merged_to_existing = {}  # Mapowanie: index punktu u≈ºytkownika -> istniejƒÖcy punkt
        
        # Dla ka≈ºdego punktu u≈ºytkownika sprawd≈∫ czy jest blisko istniejƒÖcego
        for i, (ux, uy) in enumerate(user_points_coords):
            closest_existing = None
            min_dist = float('inf')
            
            # Znajd≈∫ najbli≈ºszy istniejƒÖcy punkt
            for existing in existing_points:
                if existing['x'] == 0 and existing['y'] == 0:
                    continue
                    
                dist = math.sqrt((existing['x'] - ux)**2 + (existing['y'] - uy)**2)
                
                if dist <= merge_threshold and dist < min_dist:
                    min_dist = dist
                    closest_existing = existing
            
            if closest_existing:
                # U≈ºyj istniejƒÖcego punktu
                merged_to_existing[i] = closest_existing['id']
                merged_points.append((closest_existing['x'], closest_existing['y']))
            else:
                # Zachowaj oryginalny punkt u≈ºytkownika
                merged_points.append((ux, uy))
        
        return merged_points, merged_to_existing
    
    def simplify_user_path_points(self, points_coords):
        """Upraszcza punkty ≈õcie≈ºki u≈ºytkownika grupujƒÖc bliskie punkty"""
        if len(points_coords) <= 2:
            return points_coords
        
        merge_threshold = 40
        simplified = []
        used_indices = set()
        
        for i, (x1, y1) in enumerate(points_coords):
            if i in used_indices:
                continue
            
            # Znajd≈∫ klaster bliskich punkt√≥w
            cluster = [(x1, y1)]
            used_indices.add(i)
            
            for j, (x2, y2) in enumerate(points_coords):
                if j <= i or j in used_indices:
                    continue
                
                dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
                
                if dist <= merge_threshold:
                    cluster.append((x2, y2))
                    used_indices.add(j)
            
            # ≈örednia pozycja klastra
            avg_x = sum(p[0] for p in cluster) / len(cluster)
            avg_y = sum(p[1] for p in cluster) / len(cluster)
            simplified.append((avg_x, avg_y))
        
        return simplified
    
    def update_map_with_user_path(self):
        """Aktualizuje oryginalnƒÖ mapƒô GPS o ≈õcie≈ºkƒô u≈ºytkownika"""
        if not self.map_filename or not self.current_user_path:
            return
        
        try:
            # Wczytaj aktualnƒÖ mapƒô
            with open(self.map_filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # U≈ºyj warto≈õci z suwaka pr√≥bkowania
            sampling_rate = self.sampling_var.get()
            
            # Co N-ty punkt z narysowanej ≈õcie≈ºki (kontrolowane suwakiem)
            sampled_indices = range(0, len(self.current_user_path), sampling_rate)
            sampled_path = [self.current_user_path[i] for i in sampled_indices]
            
            # Zawsze dodaj ostatni punkt
            if len(self.current_user_path) > 0 and self.current_user_path[-1] not in sampled_path:
                sampled_path.append(self.current_user_path[-1])
            
            # Filtruj punkty kt√≥re sƒÖ za blisko siebie
            filtered_path = []
            min_distance = 30
            
            for point in sampled_path:
                if not filtered_path:
                    filtered_path.append(point)
                else:
                    last_point = filtered_path[-1]
                    dist = math.sqrt((point[0] - last_point[0])**2 + (point[1] - last_point[1])**2)
                    if dist >= min_distance:
                        filtered_path.append(point)
            
            sampled_path = filtered_path
            
            print(f"  Oryginalnych punkt√≥w: {len(self.current_user_path)}")
            print(f"  Po pr√≥bkowaniu co {sampling_rate}: {len([self.current_user_path[i] for i in sampled_indices])}")
            print(f"  Po filtrowaniu (min {min_distance}px): {len(sampled_path)}")
            
            # NOWA FUNKCJONALNO≈öƒÜ: Po≈ÇƒÖcz korytarze (2 razy)
            # Zbierz wszystkie istniejƒÖce punkty
            existing_points = []
            for path in data['paths']:
                for point in path['points']:
                    if point['x'] != 0 or point['y'] != 0:
                        existing_points.append(point)
            
            # 1. Po≈ÇƒÖcz ≈õcie≈ºkƒô u≈ºytkownika z istniejƒÖcymi punktami
            print(f"  ≈ÅƒÖczenie z istniejƒÖcymi punktami...")
            merged_with_existing, merged_map = self.merge_user_path_with_existing(sampled_path, existing_points)
            print(f"  Po po≈ÇƒÖczeniu z mapƒÖ: {len(merged_with_existing)} punkt√≥w, {len(merged_map)} zmapowanych")
            
            # 2. Upro≈õƒá wewnƒôtrzne punkty ≈õcie≈ºki u≈ºytkownika (grupuj bliskie)
            print(f"  Upraszczanie wewnƒôtrznych punkt√≥w...")
            final_path = self.simplify_user_path_points(merged_with_existing)
            print(f"  Po uproszczeniu: {len(final_path)} punkt√≥w")
            
            # Konwertuj finalne punkty na format JSON
            # Sprawd≈∫ kt√≥re punkty zosta≈Çy zmapowane na istniejƒÖce
            new_path_id = len(data['paths']) + 1
            point_id_start = max([p['id'] for path in data['paths'] for p in path['points']], default=0) + 1
            
            reused_points = {}  # ID istniejƒÖcego punktu -> lista indeks√≥w u≈ºytkownika
            new_points = []
            
            for i, (x, y) in enumerate(final_path):
                # Sprawd≈∫ czy ten punkt jest bardzo blisko istniejƒÖcego (ponowna weryfikacja)
                matched_existing = None
                for existing in existing_points:
                    if existing['x'] == 0 and existing['y'] == 0:
                        continue
                    dist = math.sqrt((existing['x'] - x)**2 + (existing['y'] - y)**2)
                    if dist < 5:  # Bardzo blisko = ten sam punkt
                        matched_existing = existing['id']
                        break
                
                if matched_existing:
                    # Reu≈ºyj istniejƒÖcy punkt
                    if matched_existing not in reused_points:
                        reused_points[matched_existing] = []
                    reused_points[matched_existing].append(i)
                else:
                    # Utw√≥rz nowy punkt
                    new_points.append({
                        'id': point_id_start + len(new_points),
                        'x': round(x, 2),
                        'y': round(y, 2)
                    })
            
            # Dodaj nowƒÖ ≈õcie≈ºkƒô TYLKO je≈õli sƒÖ nowe punkty do dodania
            if new_points:
                new_path = {
                    'id': new_path_id,
                    'points': new_points,
                    'color': 'blue'  # ≈öcie≈ºki u≈ºytkownik√≥w w kolorze niebieskim
                }
                data['paths'].append(new_path)
                
                # Dodaj po≈ÇƒÖczenia miƒôdzy punktami w nowej ≈õcie≈ºce
                for i in range(len(new_points) - 1):
                    point1 = new_points[i]
                    point2 = new_points[i + 1]
                    
                    distance = math.sqrt((point2['x'] - point1['x'])**2 + 
                                       (point2['y'] - point1['y'])**2)
                    
                    data['connections'].append({
                        'from': point1['id'],
                        'to': point2['id'],
                        'distance': round(distance, 2)
                    })
                
                # Po≈ÇƒÖcz nowƒÖ ≈õcie≈ºkƒô z istniejƒÖcymi punktami (tylko poczƒÖtki/ko≈Ñce)
                self.connect_to_existing_points(data, new_points)
            
            # Zapisz zaktualizowanƒÖ mapƒô
            with open(self.map_filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            # Zaktualizuj lokalnƒÖ kopiƒô
            self.all_paths = data['paths']
            self.all_connections = data['connections']
            
            added_msg = f"dodano {len(new_points)} nowych punkt√≥w"
            reused_msg = f"reu≈ºyto {len(reused_points)} istniejƒÖcych" if reused_points else ""
            
            print(f"‚úì Mapa zaktualizowana: {added_msg}")
            if reused_msg:
                print(f"  {reused_msg}")
            
        except Exception as e:
            print(f"‚úó B≈ÇƒÖd aktualizacji mapy: {e}")
            import traceback
            traceback.print_exc()
            messagebox.showwarning("B≈ÇƒÖd aktualizacji", 
                                 f"Nie uda≈Ço siƒô zaktualizowaƒá mapy:\n{e}")
    
    def connect_to_existing_points(self, data, new_points):
        """≈ÅƒÖczy nowƒÖ ≈õcie≈ºkƒô z istniejƒÖcymi punktami - gwarantuje po≈ÇƒÖczenia"""
        # Zbierz wszystkie istniejƒÖce punkty (opr√≥cz nowo dodanych)
        existing_points = []
        for path in data['paths'][:-1]:  # Ostatnia ≈õcie≈ºka to w≈Ça≈õnie dodana
            for point in path['points']:
                if point['x'] != 0 or point['y'] != 0:
                    existing_points.append(point)
        
        if not new_points or not existing_points:
            return
        
        def find_and_connect(target_point, point_type, initial_threshold=60):
            """Znajduje i ≈ÇƒÖczy punkt z istniejƒÖcymi - z fallbackiem na wiƒôkszy promie≈Ñ"""
            connections_made = 0
            thresholds = [initial_threshold, 100, 150, 200]  # Pr√≥buj coraz wiƒôksze promienie
            
            for threshold in thresholds:
                # Znajd≈∫ wszystkie punkty w promieniu threshold
                candidates = []
                for existing in existing_points:
                    dist = math.sqrt((existing['x'] - target_point['x'])**2 + 
                                   (existing['y'] - target_point['y'])**2)
                    if dist <= threshold:
                        candidates.append((existing, dist))
                
                if candidates:
                    # Sortuj po odleg≈Ço≈õci i po≈ÇƒÖcz z 1-3 najbli≈ºszymi
                    candidates.sort(key=lambda x: x[1])
                    max_connections = min(3, len(candidates))  # Max 3 po≈ÇƒÖczenia
                    
                    for existing, dist in candidates[:max_connections]:
                        # Sprawd≈∫ czy to po≈ÇƒÖczenie ju≈º nie istnieje
                        connection_exists = any(
                            (c['from'] == target_point['id'] and c['to'] == existing['id']) or
                            (c['from'] == existing['id'] and c['to'] == target_point['id'])
                            for c in data['connections']
                        )
                        
                        if not connection_exists:
                            data['connections'].append({
                                'from': target_point['id'],
                                'to': existing['id'],
                                'distance': round(dist, 2)
                            })
                            connections_made += 1
                            print(f"  Po≈ÇƒÖczono {point_type} z punktem {existing['id']} (odleg≈Ço≈õƒá: {dist:.1f}px, pr√≥g: {threshold}px)")
                    
                    break  # Znaleziono po≈ÇƒÖczenia, wyjd≈∫ z pƒôtli prog√≥w
            
            if connections_made == 0:
                print(f"  ‚ö† Nie znaleziono po≈ÇƒÖczenia dla {point_type} (sprawdzono do {thresholds[-1]}px)")
            
            return connections_made
        
        # Po≈ÇƒÖcz poczƒÖtek nowej ≈õcie≈ºki
        start_point = new_points[0]
        find_and_connect(start_point, "poczƒÖtku", initial_threshold=60)
        
        # Po≈ÇƒÖcz koniec nowej ≈õcie≈ºki
        end_point = new_points[-1]
        find_and_connect(end_point, "ko≈Ñca", initial_threshold=60)
    
    def clear_user_path(self):
        """Czy≈õci tylko ≈õcie≈ºkƒô u≈ºytkownika"""
        self.canvas.delete('user_path')
        self.canvas.delete('user_marker')
        self.drawn_path = []
        self.current_user_path = []
        self.user_position = None
        self.current_path_index = 0
        self.is_drawing = False
        self.user_direction = None
        self.last_positions = []
        self.deviated_from_route = False
        self.visited_nodes = []
        
        # Reset trybu wolnej eksploracji
        if self.free_exploration_mode:
            self.free_exploration_mode = False
            self.nav_frame['bg'] = '#1976D2'
            self.nav_label['bg'] = '#1976D2'
            self.distance_label['bg'] = '#1976D2'
        
        # Przygotuj nazwƒô punktu startowego
        first_point = self.shortest_path[0] if self.shortest_path else None
        first_label = self.point_labels.get(first_point, f"punkt {first_point}") if first_point else ""
        
        if self.shortest_path:
            self.nav_label['text'] = "üö∂ Rysuj swojƒÖ pozycjƒô myszkƒÖ (przeciƒÖgnij)"
            self.distance_label['text'] = f"Id≈∫ do: {first_label}" if first_label else ""
        else:
            self.nav_label['text'] = "Wczytaj mapƒô i trasƒô aby rozpoczƒÖƒá nawigacjƒô"
            self.distance_label['text'] = ""
    
    def return_to_menu(self):
        """Zamyka aplikacjƒô i wraca do menu g≈Ç√≥wnego"""
        import subprocess
        import sys
        import os
        
        result = messagebox.askyesno("Powr√≥t do Menu",
                                     "Czy na pewno chcesz wr√≥ciƒá do menu g≈Ç√≥wnego?\n\n"
                                     "Niezapisane zmiany mogƒÖ zostaƒá utracone.")
        
        if result:
            # Uruchom menu
            script_dir = os.path.dirname(os.path.abspath(__file__))
            menu_path = os.path.join(script_dir, "menu.py")
            
            if os.path.exists(menu_path):
                if sys.platform == "win32":
                    subprocess.Popen([sys.executable, menu_path])
                else:
                    subprocess.Popen([sys.executable, menu_path])
            
            # Zamknij tƒô aplikacjƒô
            self.root.quit()
            self.root.destroy()

def main():
    root = tk.Tk()
    app = GPSNavigator(root)
    root.mainloop()

if __name__ == "__main__":
    main()
